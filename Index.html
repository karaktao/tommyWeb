<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tommy — Architectural Portfolio Flipbook</title>
  <!-- PageFlip CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/stpageflip@2.0.7/dist/css/page-flip.min.css" />
  <style>
    :root{--bg:#0b0f14;--card:#11161d;--ink:#e7edf7;--muted:#9fb3c8;--accent:#5fb3ff}
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.5 ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial}
    header{position:sticky;top:0;z-index:50;background:linear-gradient(180deg,rgba(11,15,20,.9),rgba(11,15,20,.6));backdrop-filter: blur(6px);}
    .bar{max-width:1200px;margin:0 auto;display:flex;gap:.5rem;align-items:center;padding:.5rem}
    .bar h1{font-size:16px;margin:0 8px 0 0;color:var(--ink);font-weight:600}
    .btn{display:inline-flex;align-items:center;gap:.35rem;padding:.45rem .7rem;border:1px solid #263040;border-radius:10px;background:var(--card);color:var(--ink);cursor:pointer}
    .btn:hover{border-color:#2e3b4d}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .right{margin-left:auto;display:flex;gap:.5rem}
    .counter{color:var(--muted);min-width:7ch;text-align:center}
    #viewer-wrap{max-width:1200px;margin:10px auto 30px;padding:0 10px}
    #flipbook{width:100%;height:75vh;border-radius:16px;overflow:hidden;background:radial-gradient(circle at 50% 0%,#16202b,#0b0f14 60%)}
    /* thumbnails */
    #thumbs{max-width:1200px;margin:8px auto;display:flex;gap:.5rem;overflow:auto;padding:0 10px}
    #thumbs canvas{height:80px;border-radius:8px;border:1px solid #243040;cursor:pointer;opacity:.75}
    #thumbs canvas:hover{opacity:1}
    .hint{max-width:1200px;margin:6px auto 0;color:var(--muted);padding:0 12px}
    a{color:var(--accent)}
  </style>
</head>
<body>
<header>
  <div class="bar">
    <h1>建筑作品集 · Flipbook</h1>
    <button id="prev" class="btn" title="上一页">◀︎ Prev</button>
    <div class="counter"><span id="cp">1</span>/<span id="tp">…</span></div>
    <button id="next" class="btn" title="下一页">Next ▶︎</button>

    <div class="right">
      <button id="toggleMode" class="btn" title="单页/对页显示">Toggle Single/Spread</button>
      <button id="download" class="btn" title="下载PDF">Download PDF</button>
      <button id="full" class="btn" title="全屏">Fullscreen</button>
    </div>
  </div>
</header>

<div id="viewer-wrap">
  <div id="flipbook"></div>
</div>
<div id="thumbs"></div>
<p class="hint">提示：支持对页浏览与“拼接展示”。如果某些作品需要<strong>左右两页拼接为一页</strong>，请在下方脚本中的 <code>spreadPairs</code> 中填入页码对（如 <code>[4,5]</code>）。拼接后这两页会被当作一页展示并带有翻页效果。</p>

<!-- pdf.js -->
<script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
<script>
  // worker
  pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
</script>
<!-- PageFlip (no jQuery required) -->
<script src="https://cdn.jsdelivr.net/npm/stpageflip@2.0.7/dist/js/page-flip.browser.min.js"></script>
<script>
(async function(){
  // === CONFIG ===
  const pdfUrl = 'architecturalDesignPortfolio.pdf'; // 放在同目录
  // 需要“拼接显示”的对页（从1开始）。示例：第4-5页做成一张跨页
  const spreadPairs = [/* [4,5], [10,11] */];

  // 目标渲染大小（像素）。会自适应缩放
  const TARGET_W = 1400; // 单页画布宽
  const TARGET_H = 1980; // 单页画布高（按A4/竖版比例）

  const $ = (s)=>document.querySelector(s);
  const flipEl = $('#flipbook');
  const thumbsEl = $('#thumbs');
  const cpEl = $('#cp');
  const tpEl = $('#tp');

  const pdf = await pdfjsLib.getDocument({url: pdfUrl}).promise;
  const total = pdf.numPages;

  // 计算“展示序列”：普通单页 or 拼接跨页
  const spreadSet = new Set(spreadPairs.map(p=>p[0]+'-'+p[1]));
  const toDisplay = []; // {type:'single', n} | {type:'spread', l, r}
  let i=1;
  while(i<=total){
    const key = i+'-'+(i+1);
    if(spreadSet.has(key)){
      toDisplay.push({type:'spread', l:i, r:i+1});
      i+=2;
    }else{
      toDisplay.push({type:'single', n:i});
      i+=1;
    }
  }
  tpEl.textContent = toDisplay.length;


// 兼容两种命名空间：PageFlip (新) / St.PageFlip (旧)
const PF = window.PageFlip || (window.St && window.St.PageFlip);
  if (!PF) {
    console.error('PageFlip library not loaded. Check the CDN script.');
    alert('PageFlip 库未加载成功，请检查网络或脚本地址。');
    return;
  }

  const pageFlip = new PF(flipEl, {
    width: TARGET_W,
    height: TARGET_H,
    maxShadowOpacity: 0.2,
    showCover: false,
    useMouseEvents: true,
    mobileScrollSupport: true,
    disableFlipByClick: false,
    autoSize: true,
  });

  // 生成占位页（真实图像按需懒加载）
  const pages = toDisplay.map((entry, idx)=>{
    const page = document.createElement('div');
    page.className = 'page';
    page.style.width = TARGET_W+'px';
    page.style.height = TARGET_H+'px';
    const canvas = document.createElement('canvas');
    canvas.width = TARGET_W; canvas.height = TARGET_H;
    canvas.dataset.rendered = '0';
    page.appendChild(canvas);
    return {entry, idx, page, canvas};
  });

  pageFlip.loadFromHTML(pages.map(p=>p.page));

  // 渲染函数（单页）
  async function renderSingle(n, canvas){
    const page = await pdf.getPage(n);
    // 以目标高度为准计算缩放
    const viewport = page.getViewport({scale:1});
    const scale = Math.min(TARGET_W/viewport.width, TARGET_H/viewport.height);
    const v = page.getViewport({scale});
    const ctx = canvas.getContext('2d');
    // 清空
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // 居中绘制
    const off = document.createElement('canvas');
    off.width = Math.round(v.width); off.height = Math.round(v.height);
    await page.render({canvasContext: off.getContext('2d'), viewport: v}).promise;
    const x = (canvas.width - off.width)/2;
    const y = (canvas.height - off.height)/2;
    ctx.drawImage(off, x, y);
  }

  // 渲染函数（拼接跨页，将两页左右各缩放一半宽度后塞入同一画布）
  async function renderSpread(l, r, canvas){
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const left = await pdf.getPage(l);
    const right = await pdf.getPage(r);

    // 每页占画布的一半宽度
    const halfW = canvas.width/2;
    // 以高度为准缩放
    const vL0 = left.getViewport({scale:1});
    const vR0 = right.getViewport({scale:1});
    const sL = Math.min(halfW/vL0.width, canvas.height/vL0.height);
    const sR = Math.min(halfW/vR0.width, canvas.height/vR0.height);
    const vL = left.getViewport({scale:sL});
    const vR = right.getViewport({scale:sR});

    const offL = document.createElement('canvas');
    offL.width = Math.round(vL.width); offL.height = Math.round(vL.height);
    await left.render({canvasContext: offL.getContext('2d'), viewport: vL}).promise;

    const offR = document.createElement('canvas');
    offR.width = Math.round(vR.width); offR.height = Math.round(vR.height);
    await right.render({canvasContext: offR.getContext('2d'), viewport: vR}).promise;

    const yL = (canvas.height - offL.height)/2;
    const yR = (canvas.height - offR.height)/2;
    // 左右各居中在半幅
    ctx.drawImage(offL, (halfW-offL.width)/2, yL);
    ctx.drawImage(offR, halfW + (halfW-offR.width)/2, yR);

    // 中缝细线（可选）
    ctx.fillStyle = '#e5e7eb';
    ctx.fillRect(canvas.width/2 - .5, 0, 1, canvas.height);
  }

  // 懒加载：渲染当前/前/后页
  async function ensureRendered(index){
    for(const j of [index-1,index,index+1]){
      if(j<0 || j>=pages.length) continue;
      const p = pages[j];
      if(p.canvas.dataset.rendered==='1') continue;
      if(p.entry.type==='single') await renderSingle(p.entry.n, p.canvas);
      else await renderSpread(p.entry.l, p.entry.r, p.canvas);
      p.canvas.dataset.rendered='1';
    }
  }

  pageFlip.on('init', async ()=>{
    await ensureRendered(0);
  });

  pageFlip.on('flip', async (e)=>{
    cpEl.textContent = String(e.data+1);
    await ensureRendered(e.data);
  });

  // 控件
  $('#prev').onclick = ()=>pageFlip.flipPrev();
  $('#next').onclick = ()=>pageFlip.flipNext();

  $('#toggleMode').onclick = ()=>{
    const current = pageFlip.getSettings();
    const newSingle = !current.singlePageMode;
    pageFlip.update({ singlePageMode: newSingle });
  };

  $('#download').onclick = ()=>{ window.open(pdfUrl, '_blank'); };
  $('#full').onclick = ()=>{
    const el = document.documentElement;
    if(!document.fullscreenElement){ el.requestFullscreen?.(); }
    else { document.exitFullscreen?.(); }
  };

  // 生成缩略图（低成本渲染）
  for(let k=0;k<toDisplay.length;k++){
    const tcv = document.createElement('canvas');
    tcv.height = 120; tcv.width = 120/1.4142; // 约等A系列比例
    const tctx = tcv.getContext('2d');
    tctx.fillStyle = '#ffffff';
    tctx.fillRect(0,0,tcv.width,tcv.height);
    thumbsEl.appendChild(tcv);

    // 用同一套渲染，但用小画布
    if(toDisplay[k].type==='single'){
      const page = await pdf.getPage(toDisplay[k].n);
      const v0 = page.getViewport({scale:1});
      const s = Math.min(tcv.width/v0.width, tcv.height/v0.height);
      const v = page.getViewport({scale:s});
      const off = document.createElement('canvas'); off.width=v.width; off.height=v.height;
      await page.render({canvasContext: off.getContext('2d'), viewport: v}).promise;
      tctx.drawImage(off, (tcv.width-off.width)/2, (tcv.height-off.height)/2);
    }else{
      const l = await pdf.getPage(toDisplay[k].l);
      const r = await pdf.getPage(toDisplay[k].r);
      const vL0 = l.getViewport({scale:1});
      const vR0 = r.getViewport({scale:1});
      const half = tcv.width/2;
      const sL = Math.min(half/vL0.width, tcv.height/vL0.height);
      const sR = Math.min(half/vR0.width, tcv.height/vR0.height);
      const vL = l.getViewport({scale:sL});
      const vR = r.getViewport({scale:sR});
      const offL = document.createElement('canvas'); offL.width=vL.width; offL.height=vL.height;
      const offR = document.createElement('canvas'); offR.width=vR.width; offR.height=vR.height;
      await l.render({canvasContext: offL.getContext('2d'), viewport: vL}).promise;
      await r.render({canvasContext: offR.getContext('2d'), viewport: vR}).promise;
      tctx.drawImage(offL, (half-offL.width)/2, (tcv.height-offL.height)/2);
      tctx.drawImage(offR, half+(half-offR.width)/2, (tcv.height-offR.height)/2);
      tctx.fillStyle = '#e5e7eb'; tctx.fillRect(tcv.width/2-0.5,0,1,tcv.height);
    }

    tcv.onclick = ()=>{
      pageFlip.flip(k);
    };
  }
})();
</script>
</body>
</html>
