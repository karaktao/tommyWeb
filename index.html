<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Architectural Portfolio_Tommy</title>
    <style>
        :root {
            --bg: #0b0f14;
            --ink: #e7edf7;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            color: var(--ink);
            font: 14px/1.5 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;

            /* 背景：渐变 + 细微暗纹理（不抢画面） */
            background:
                radial-gradient(1200px 560px at 50% 15%, #101925 0%, #0a131d 45%, #071119 100%) fixed,
                linear-gradient(180deg, rgba(255, 255, 255, .02), rgba(255, 255, 255, .00)) fixed;
            background-attachment: fixed;
        }

        /* 容器：上下留白（呼吸空间），两侧自适应；不会贴满窗口边缘 */
        .wrap {
            max-width: min(1200px, 92vw);
            margin-inline: auto;
            padding-inline: clamp(10px, 2vw, 24px);
            padding-block: clamp(16px, 6vh, 80px);
            /* 上下留白 */
            position: relative;
        }

        /* 暖白纸张（避免跟冷灰背景混色），细边框+外阴影 */
        #flipbook {
            position: relative;
            width: 100%;
            height: clamp(420px, 78vh, 1200px);
            border-radius: 10px;
            background: #f1f1f1;
            /* 比 #fff 更暖，更容易与背景分离 */
            box-shadow:
                0 22px 60px rgba(0, 0, 0, .52),
                /* 主阴影：更深一点 */
                0 0 160px rgba(95, 179, 255, .07);
            /* 冷色柔光：极低不透明 */
            outline: 1px solid rgba(20, 28, 38, .14);
            /* 细描边：防止边缘消失 */
            overflow: hidden;
            user-select: none;
        }

        /* 边角暗角：让纸边不“发灰”——注意不宜过重 */
        #flipbook::after {
            content: "";
            position: absolute;
            inset: 0;
            pointer-events: none;
            box-shadow:
                inset 0 0 160px rgba(0, 0, 0, .22),
                inset 0 0 320px rgba(0, 0, 0, .16);
        }

    

        /* PageFlip 内部 page 容器（尺寸由 JS 注入，不再写死） */
        .page {
            position: relative;
        }

        .page canvas,
        .page img {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
        }

        /* 骨架屏动画（首帧占位） */
        .skeleton {
            background: linear-gradient(90deg, #f3f5f7 25%, #eceff2 37%, #f3f5f7 63%);
            background-size: 400% 100%;
            animation: shimmer 1.4s ease infinite;
        }

        @keyframes shimmer {
            0% {
                background-position: 100% 0
            }

            100% {
                background-position: 0 0
            }
        }

        /* —— 中缝分割线（浅灰渐变线，模拟纸缝；覆盖 PageFlip 默认阴影） —— */
        .st-page-book .st-page-shadow {
            background: linear-gradient(90deg,
                    rgba(200, 200, 200, 0.0) 49.2%,
                    rgba(200, 200, 200, 0.45) 50%,
                    rgba(200, 200, 200, 0.0) 50.8%) !important;
            box-shadow: none !important;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div id="flipbook"></div>
    </div>

    <!-- 本地脚本：pdf.js & PageFlip -->
    <script src="./libs/pdf.min.js"></script>
    <script>
        if (window.pdfjsLib) {
            pdfjsLib.GlobalWorkerOptions.workerSrc = "./libs/pdf.worker.min.js";
        }
    </script>
    <script src="./libs/page-flip.browser.js"></script>

    <script>
        (async function () {
            const pdfUrl = "./architecturalDesignPortfolio.pdf";

            // ===== 小工具 =====
            const $ = s => document.querySelector(s);
            const idle = window.requestIdleCallback || (fn => setTimeout(fn, 50));

            // ===== 以 23cm × 21cm 的纸张比例渲染 =====
            const CM_W = 23, CM_H = 21;                  // 实际尺寸（厘米）
            const RATIO = CM_H / CM_W;                   // 高宽比 = 21/23
            const PAGE_W = 1100;                         // 逻辑基准宽度（像素，可调）
            const PAGE_H = Math.round(PAGE_W * RATIO);   // 严格按 23:21 比例计算高度

            // 限制渲染像素密度，避免超高分屏过慢
            const DPR_CAP = 1.5;
            const DPR = Math.min(window.devicePixelRatio || 1, DPR_CAP);

            // ===== 初始化 PageFlip（柔和翻页，阴影更轻） =====
            const flipRoot = $("#flipbook");
            const PFClass = window.PageFlip || (window.St && window.St.PageFlip);
            const pageFlip = new PFClass(flipRoot, {
                width: PAGE_W,
                height: PAGE_H,
                size: "stretch",
                flippingTime: 800,          // 动画更柔和
                maxShadowOpacity: 0.10,      // 阴影更轻，配合中缝灰线
                showCover: false,
                mobileScrollSupport: true,
                useMouseEvents: true,
                disableFlipByClick: false,
                startZIndex: 3,
                singlePageMode: false
            });

            // 键盘导航
            window.addEventListener("keydown", e => {
                if (e.key === "ArrowLeft") pageFlip.flipPrev();
                else if (e.key === "ArrowRight") pageFlip.flipNext();
            });

            // ===== 加载 PDF =====
            let pdf;
            try {
                pdf = await pdfjsLib.getDocument({ url: pdfUrl }).promise;
            } catch (e) {
                console.error(e);
                flipRoot.innerHTML = "<div style='padding:16px'>PDF 加载失败，请确认文件路径与大小写。</div>";
                return;
            }
            const total = pdf.numPages;

            // ===== DOM 预构建（先放白纸骨架） =====
            const pages = [];
            const frag = document.createDocumentFragment();
            for (let i = 1; i <= total; i++) {
                const holder = document.createElement("div");
                holder.className = "page";
                holder.style.width = PAGE_W + "px";
                holder.style.height = PAGE_H + "px";

                const canvas = document.createElement("canvas");
                canvas.width = Math.round(PAGE_W * DPR);
                canvas.height = Math.round(PAGE_H * DPR);
                canvas.style.width = "100%";
                canvas.style.height = "100%";
                canvas.className = "skeleton";
                canvas.dataset.pageIndex = String(i);
                canvas.dataset.ready = "0";
                holder.appendChild(canvas);

                frag.appendChild(holder);
                pages.push(holder);
            }
            flipRoot.appendChild(frag);
            pageFlip.loadFromHTML(flipRoot.querySelectorAll(".page"));

            // ===== 渲染缓存（ImageBitmap） =====
            const pageBitmapCache = new Map(); // i -> ImageBitmap
            const pageObjCache = new Map();    // i -> pdfPage

            async function getPdfPage(i) {
                if (pageObjCache.has(i)) return pageObjCache.get(i);
                const p = await pdf.getPage(i);
                pageObjCache.set(i, p);
                return p;
            }

            const queue = []; let busy = false;
            function enqueue(i, priority = 10) {
                if (pageBitmapCache.has(i)) return;
                if (queue.find(it => it.i === i)) return;
                queue.push({ i, priority });
                queue.sort((a, b) => a.priority - b.priority);
                pump();
            }
            async function pump() {
                if (busy) return;
                busy = true;
                while (queue.length) {
                    const { i } = queue.shift();
                    if (pageBitmapCache.has(i)) continue;
                    try { await renderToBitmap(i); } catch (e) { console.warn("render fail p" + i, e); }
                }
                busy = false;
            }

            async function renderToBitmap(i) {
                const page = await getPdfPage(i);
                const v0 = page.getViewport({ scale: 1 });
                const scale = Math.min((PAGE_W * DPR) / v0.width, (PAGE_H * DPR) / v0.height);
                const viewport = page.getViewport({ scale });

                const off = (typeof OffscreenCanvas !== "undefined")
                    ? new OffscreenCanvas(Math.round(viewport.width), Math.round(viewport.height))
                    : Object.assign(document.createElement("canvas"), { width: Math.round(viewport.width), height: Math.round(viewport.height) });

                const ctx = off.getContext("2d", { alpha: false });
                await page.render({ canvasContext: ctx, viewport }).promise;

                const bmp = await createImageBitmap(off);
                pageBitmapCache.set(i, bmp);

                const ph = pages[i - 1].querySelector("canvas");
                if (ph && ph.dataset.ready === "0") {
                    const ctx2 = ph.getContext("2d");
                    ctx2.imageSmoothingEnabled = true;
                    ctx2.clearRect(0, 0, ph.width, ph.height);
                    const dx = Math.round((ph.width - bmp.width) / 2);
                    const dy = Math.round((ph.height - bmp.height) / 2);
                    ctx2.drawImage(bmp, dx, dy);
                    ph.classList.remove("skeleton");
                    ph.dataset.ready = "1";
                }
            }

            // ===== 预取：当前页前后各 2 页，并空闲时多预一点 =====
            const WINDOW = 2;
            async function warmAround(viewIndex) {
                const p = viewIndex + 1;
                const targets = new Set();
                for (let k = -WINDOW; k <= WINDOW; k++) {
                    const idx = p + k;
                    if (idx >= 1 && idx <= total) targets.add(idx);
                }
                [...targets].sort((a, b) => Math.abs(a - p) - Math.abs(b - p))
                    .forEach((idx, ord) => enqueue(idx, ord));
                idle(() => {
                    for (let j = p + WINDOW + 1; j <= Math.min(total, p + WINDOW + 4); j++) {
                        enqueue(j, 99 + j);
                    }
                });
            }

            pageFlip.on("init", async () => { await warmAround(0); });
            pageFlip.on("flip", async e => { await warmAround(e.data); });

            pageFlip.turnToPage(0);

            // ===== 自适应（重排 PageFlip，不重渲 PDF） =====
            let resizeTimer = null;
            window.addEventListener("resize", () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => pageFlip.updateFromHtml(), 120);
            });
        })();
    </script>
</body>

</html>