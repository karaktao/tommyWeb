<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tommy — Architectural Portfolio Flipbook</title>

  <!-- PageFlip CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/stpageflip@2.0.7/dist/css/page-flip.min.css" />

  <style>
    :root{--bg:#0b0f14;--card:#11161d;--ink:#e7edf7;--muted:#9fb3c8;--accent:#5fb3ff}
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.5 ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial}
    header{position:sticky;top:0;z-index:50;background:linear-gradient(180deg,rgba(11,15,20,.9),rgba(11,15,20,.6));backdrop-filter: blur(6px);}
    .bar{max-width:1200px;margin:0 auto;display:flex;gap:.5rem;align-items:center;padding:.5rem}
    .bar h1{font-size:16px;margin:0 8px 0 0;color:var(--ink);font-weight:600}
    .btn{display:inline-flex;align-items:center;gap:.35rem;padding:.45rem .7rem;border:1px solid #263040;border-radius:10px;background:var(--card);color:var(--ink);cursor:pointer}
    .btn:hover{border-color:#2e3b4d}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .right{margin-left:auto;display:flex;gap:.5rem}
    .counter{color:var(--muted);min-width:7ch;text-align:center}
    #viewer-wrap{max-width:1200px;margin:10px auto 30px;padding:0 10px}
    #flipbook{width:100%;height:75vh;border-radius:16px;overflow:hidden;background:radial-gradient(circle at 50% 0%,#16202b,#0b0f14 60%)}
    /* thumbnails */
    #thumbs{max-width:1200px;margin:8px auto;display:flex;gap:.5rem;overflow:auto;padding:0 10px}
    #thumbs canvas{height:80px;border-radius:8px;border:1px solid #243040;cursor:pointer;opacity:.75}
    #thumbs canvas:hover{opacity:1}
    .hint{max-width:1200px;margin:6px auto 0;color:var(--muted);padding:0 12px}
    a{color:var(--accent)}
    /* loading */
    #loading{max-width:1200px;margin:20px auto;padding:12px;color:var(--muted);text-align:center}
  </style>
</head>
<body>
<header>
  <div class="bar">
    <h1>建筑作品集 · Flipbook</h1>
    <button id="prev" class="btn" title="上一页">◀︎ Prev</button>
    <div class="counter"><span id="cp">1</span>/<span id="tp">…</span></div>
    <button id="next" class="btn" title="下一页">Next ▶︎</button>

    <div class="right">
      <button id="toggleMode" class="btn" title="单页/对页显示">Toggle Single/Spread</button>
      <button id="download" class="btn" title="下载PDF">Download PDF</button>
      <button id="full" class="btn" title="全屏">Fullscreen</button>
    </div>
  </div>
</header>

<div id="viewer-wrap">
  <div id="flipbook"></div>
</div>
<div id="thumbs"></div>
<div id="loading">Loading… 正在加载脚本与PDF，请稍候</div>

<p class="hint">提示：支持对页浏览与“拼接展示”。如果某些作品需要<strong>左右两页拼接为一页</strong>，请在下方脚本中的 <code>spreadPairs</code> 中填入页码对（如 <code>[4,5]</code>）。拼接后这两页会被当作一页展示并带有翻页效果。</p>

<!-- pdf.js -->
<script defer src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
<script defer>
  // 设置 worker（必须 https）
  window.pdfjsLib && (pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js");
</script>

<!-- PageFlip（browser 版本，无需 jQuery） -->
<script defer src="https://cdn.jsdelivr.net/npm/stpageflip@2.0.7/dist/js/page-flip.browser.min.js"></script>

<!-- 主逻辑 -->
<script defer>
(async function(){

  // ======== 基本配置 ========
  const pdfUrl = './architecturalDesignPortfolio.pdf'; // PDF 与 index.html 同目录
  // 需要“拼接显示”的对页（1 起始）。例：第 4-5 页跨页
  const spreadPairs = [/* [4,5], [10,11] */];

  // 目标渲染大小（像素）。按 A4 竖版比例，PageFlip 会自适应缩放
  const TARGET_W = 1400; // 单页画布宽
  const TARGET_H = 1980; // 单页画布高

  const $ = (s)=>document.querySelector(s);
  const flipEl   = $('#flipbook');
  const thumbsEl = $('#thumbs');
  const cpEl     = $('#cp');
  const tpEl     = $('#tp');
  const loading  = $('#loading');

  // ======== 等待依赖加载（最多 5s）========
  function waitForLibs(timeoutMs=5000, interval=50){
    return new Promise((resolve, reject)=>{
      const t0 = Date.now();
      const timer = setInterval(()=>{
        const PF = window.PageFlip || (window.St && window.St.PageFlip);
        if (window.pdfjsLib && PF){
          clearInterval(timer); resolve(PF);
        }else if (Date.now() - t0 > timeoutMs){
          clearInterval(timer); reject(new Error('Libraries not ready in time'));
        }
      }, interval);
    });
  }

  let PF;
  try{
      PF = await waitForLibs();
  }catch(err){
      console.error('依赖加载失败：', err, {pdfjsLib: !!window.pdfjsLib, PageFlip: !!(window.PageFlip || (window.St && window.St.PageFlip))});
      alert('PageFlip 或 PDF 库未加载成功，请检查网络或脚本地址（控制台查看详情）。');
      return;
  }

  // ======== 读取 PDF ========
  let pdf;
  try{
    pdf = await pdfjsLib.getDocument({url: pdfUrl}).promise;
  }catch(err){
    console.error('PDF 加载失败：', err);
    alert('PDF 加载失败：请确认文件已放在同目录，文件名与大小写正确，且通过 HTTPS 访问。');
    return;
  }
  const total = pdf.numPages;

  // ======== 计算展示序列：单页 / 跨页 ========
  const spreadSet = new Set(spreadPairs.map(p=>p[0]+'-'+p[1]));
  const toDisplay = []; // {type:'single', n} | {type:'spread', l, r}
  for(let i=1;i<=total;){
    const key = i+'-'+(i+1);
    if(spreadSet.has(key) && i+1<=total){
      toDisplay.push({type:'spread', l:i, r:i+1});
      i += 2;
    }else{
      toDisplay.push({type:'single', n:i});
      i += 1;
    }
  }
  tpEl.textContent = toDisplay.length;

  // ======== 初始化 PageFlip ========
  const pageFlip = new PF(flipEl, {
    width: TARGET_W,
    height: TARGET_H,
    maxShadowOpacity: 0.2,
    showCover: false,
    useMouseEvents: true,
    mobileScrollSupport: true,
    disableFlipByClick: false,
    autoSize: true,
    singlePageMode: false
  });

  // 生成占位页（真实图像按需懒加载）
  const pages = toDisplay.map((entry)=>{
    const page = document.createElement('div');
    page.className = 'page';
    page.style.width = TARGET_W+'px';
    page.style.height = TARGET_H+'px';
    const canvas = document.createElement('canvas');
    canvas.width = TARGET_W; canvas.height = TARGET_H;
    canvas.dataset.rendered = '0';
    page.appendChild(canvas);
    return {entry, page, canvas};
  });

  pageFlip.loadFromHTML(pages.map(p=>p.page));

  // ======== 渲染函数 ========
  async function renderSingle(n, canvas){
    const page = await pdf.getPage(n);
    const viewport = page.getViewport({scale:1});
    const scale = Math.min(TARGET_W/viewport.width, TARGET_H/viewport.height);
    const v = page.getViewport({scale});
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const off = document.createElement('canvas');
    off.width = Math.round(v.width); off.height = Math.round(v.height);
    await page.render({canvasContext: off.getContext('2d'), viewport: v}).promise;
    const x = (canvas.width - off.width)/2;
    const y = (canvas.height - off.height)/2;
    ctx.drawImage(off, x, y);
  }

  async function renderSpread(l, r, canvas){
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const left = await pdf.getPage(l);
    const right = await pdf.getPage(r);

    const halfW = canvas.width/2;
    const vL0 = left.getViewport({scale:1});
    const vR0 = right.getViewport({scale:1});
    const sL = Math.min(halfW/vL0.width, canvas.height/vL0.height);
    const sR = Math.min(halfW/vR0.width, canvas.height/vR0.height);
    const vL = left.getViewport({scale:sL});
    const vR = right.getViewport({scale:sR});

    const offL = document.createElement('canvas');
    offL.width = Math.round(vL.width); offL.height = Math.round(vL.height);
    await left.render({canvasContext: offL.getContext('2d'), viewport: vL}).promise;

    const offR = document.createElement('canvas');
    offR.width = Math.round(vR.width); offR.height = Math.round(vR.height);
    await right.render({canvasContext: offR.getContext('2d'), viewport: vR}).promise;

    const yL = (canvas.height - offL.height)/2;
    const yR = (canvas.height - offR.height)/2;
    ctx.drawImage(offL, (halfW-offL.width)/2, yL);
    ctx.drawImage(offR, halfW + (halfW-offR.width)/2, yR);

    // 中缝
    ctx.fillStyle = '#e5e7eb';
    ctx.fillRect(canvas.width/2 - .5, 0, 1, canvas.height);
  }

  // 懒加载：渲染当前/前/后页
  async function ensureRendered(index){
    for(const j of [index-1,index,index+1]){
      if(j<0 || j>=pages.length) continue;
      const p = pages[j];
      if(p.canvas.dataset.rendered==='1') continue;
      if(p.entry.type==='single') await renderSingle(p.entry.n, p.canvas);
      else await renderSpread(p.entry.l, p.entry.r, p.canvas);
      p.canvas.dataset.rendered='1';
    }
  }

  pageFlip.on('init', async ()=>{
    loading.textContent = 'Rendering… 正在渲染首页';
    await ensureRendered(0);
    loading.remove();
  });

  pageFlip.on('flip', async (e)=>{
    cpEl.textContent = String(e.data+1);
    await ensureRendered(e.data);
  });

  // ======== 控件 ========
  $('#prev').onclick = ()=>pageFlip.flipPrev();
  $('#next').onclick = ()=>pageFlip.flipNext();

  $('#toggleMode').onclick = ()=>{
    const current = pageFlip.getSettings();
    pageFlip.update({ singlePageMode: !current.singlePageMode });
  };

  $('#download').onclick = ()=>{ window.open(pdfUrl, '_blank'); };
  $('#full').onclick = ()=>{
    const el = document.documentElement;
    if(!document.fullscreenElement){ el.requestFullscreen?.(); }
    else { document.exitFullscreen?.(); }
  };

  // ======== 生成缩略图 ========
  for(let k=0;k<toDisplay.length;k++){
    const tcv = document.createElement('canvas');
    tcv.height = 120; tcv.width = Math.round(120/1.4142); // A 系列比例
    const tctx = tcv.getContext('2d');
    tctx.fillStyle = '#ffffff';
    tctx.fillRect(0,0,tcv.width,tcv.height);
    thumbsEl.appendChild(tcv);

    if(toDisplay[k].type==='single'){
      const page = await pdf.getPage(toDisplay[k].n);
      const v0 = page.getViewport({scale:1});
      const s = Math.min(tcv.width/v0.width, tcv.height/v0.height);
      const v = page.getViewport({scale:s});
      const off = document.createElement('canvas'); off.width=v.width; off.height=v.height;
      await page.render({canvasContext: off.getContext('2d'), viewport: v}).promise;
      tctx.drawImage(off, (tcv.width-off.width)/2, (tcv.height-off.height)/2);
    }else{
      const l = await pdf.getPage(toDisplay[k].l);
      const r = await pdf.getPage(toDisplay[k].r);
      const vL0 = l.getViewport({scale:1});
      const vR0 = r.getViewport({scale:1});
      const half = tcv.width/2;
      const sL = Math.min(half/vL0.width, tcv.height/vL0.height);
      const sR = Math.min(half/vR0.width, tcv.height/vR0.height);
      const vL = l.getViewport({scale:sL});
      const vR = r.getViewport({scale:sR});
      const offL = document.createElement('canvas'); offL.width=vL.width; offL.height=vL.height;
      const offR = document.createElement('canvas'); offR.width=vR.width; offR.height=vR.height;
      await l.render({canvasContext: offL.getContext('2d'), viewport: vL}).promise;
      await r.render({canvasContext: offR.getContext('2d'), viewport: vR}).promise;
      tctx.drawImage(offL, (half-offL.width)/2, (tcv.height-offL.height)/2);
      tctx.drawImage(offR, half+(half-offR.width)/2, (tcv.height-offR.height)/2);
      tctx.fillStyle = '#e5e7eb'; tctx.fillRect(tcv.width/2-0.5,0,1,tcv.height);
    }

    tcv.onclick = ()=>pageFlip.flip(k);
  }

})();
</script>
</body>
</html>
